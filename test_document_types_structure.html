<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Test - Structure des Types de Documents</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .test-result {
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .code-block {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .input-group {
            margin: 15px 0;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .result-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            min-height: 100px;
            white-space: pre-wrap;
        }
        .structure-info {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Test - Structure des Types de Documents</h1>
            <p>V√©rification de la structure des donn√©es et correction de l'erreur "type.libelle is undefined"</p>
        </div>

        <div class="test-section">
            <h2>‚úÖ Probl√®me identifi√© et corrig√©</h2>
            <div class="test-result success">
                <strong>Probl√®me r√©solu :</strong> L'erreur "TypeError: can't access property 'toLowerCase', type.libelle is undefined" √©tait caus√©e par une mauvaise structure de donn√©es.
            </div>
            
            <h3>üîç Cause du probl√®me :</h3>
            <div class="code-block">
// ‚ùå AVANT - Code incorrect
const matchingType = data.find(
    (type) =>
        type.libelle.toLowerCase() === demande.documentTypeDisplay?.toLowerCase()  // ‚Üê type.libelle n'existe pas !
);

// ‚úÖ APR√àS - Code corrig√©
const matchingType = data.find(
    (type) =>
        type.label?.toLowerCase() === demande.documentTypeDisplay?.toLowerCase()  // ‚Üê type.label existe !
);
            </div>
        </div>

        <div class="test-section">
            <h2>üìã Structure des donn√©es API</h2>
            <div class="structure-info">
                <strong>API :</strong> <code>GET /api/demandes/document-types</code><br>
                <strong>Structure retourn√©e :</strong> <code>[{value: "1", label: "Passeport"}, {value: "2", label: "Acte de naissance"}]</code>
            </div>
            
            <div class="code-block">
// Backend - DemandeController.java
@GetMapping("/document-types")
public ResponseEntity<List<Map<String, String>>> getDocumentTypes() {
    List<DocumentType> documentTypes = documentTypeRepository.findByIsActiveTrue();
    
    List<Map<String, String>> types = new ArrayList<>();
    for (DocumentType docType : documentTypes) {
        Map<String, String> typeMap = new HashMap<>();
        typeMap.put("value", docType.getId().toString());        // ‚Üê "value" contient l'ID
        typeMap.put("label", docType.getLibelle());              // ‚Üê "label" contient le libell√©
        types.add(typeMap);
    }
    return ResponseEntity.ok(types);
}
            </div>
        </div>

        <div class="test-section">
            <h2>üéØ Solution impl√©ment√©e</h2>
            
            <h3>1. Correction de la structure des donn√©es :</h3>
            <div class="code-block">
// AVANT - Utilisation incorrecte
type.libelle.toLowerCase()  // ‚Üê Propri√©t√© inexistante
type.id                     // ‚Üê Propri√©t√© inexistante

// APR√àS - Utilisation correcte
type.label?.toLowerCase()   // ‚Üê Propri√©t√© correcte
type.value                  // ‚Üê Propri√©t√© correcte
            </div>

            <h3>2. Ajout de v√©rifications de s√©curit√© :</h3>
            <div class="code-block">
// V√©rification de s√©curit√© ajout√©e
if (!Array.isArray(data) || data.length === 0) {
    console.warn("Aucun type de document trouv√© ou structure invalide");
    setDocumentTypes([]);
    setSelectedDocumentType({});
    return;
}

// V√©rifier que chaque type a les propri√©t√©s requises
const validTypes = data.filter(type => 
    type && 
    typeof type === 'object' && 
    type.value && 
    type.label
);
            </div>

            <h3>3. Gestion d'erreur robuste :</h3>
            <div class="code-block">
try {
    // ... logique de mapping ...
} catch (err) {
    console.error("Erreur lors du chargement des types de documents:", err);
    setDocumentTypes([]);
    setSelectedDocumentType({});
}
            </div>
        </div>

        <div class="test-section">
            <h2>üß™ Test de la correction</h2>
            
            <div class="input-group">
                <label for="authToken">Token d'authentification :</label>
                <input type="text" id="authToken" placeholder="Bearer token..." style="width: 100%;">
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <button class="button" onclick="testDocumentTypesStructure()">üîç Tester la structure des types</button>
                <button class="button" onclick="testMappingLogic()">üß† Tester la logique de mapping</button>
                <button class="button" onclick="runCompleteTest()">üß™ Test complet</button>
            </div>

            <div class="result-box" id="testResult">R√©sultats des tests...</div>
        </div>

        <div class="test-section">
            <h2>üìä R√©sultat attendu</h2>
            <div class="test-result info">
                <strong>Avant la correction :</strong><br>
                ‚ùå Erreur "type.libelle is undefined"<br>
                ‚ùå Impossible de charger les types de documents<br>
                ‚ùå S√©lecteur vide dans l'interface
            </div>
            
            <div class="test-result success">
                <strong>Apr√®s la correction :</strong><br>
                ‚úÖ Types de documents charg√©s correctement<br>
                ‚úÖ Mapping intelligent fonctionnel<br>
                ‚úÖ S√©lecteur rempli avec les bonnes options<br>
                ‚úÖ Gestion d'erreur robuste
            </div>
        </div>

        <div class="test-section">
            <h2>üîß Fichiers modifi√©s</h2>
            <ul>
                <li><strong>frontend/src/components/AdminDemandesList.jsx</strong> - Correction de la structure des donn√©es</li>
                <li><strong>Correction du mapping</strong> - type.libelle ‚Üí type.label</li>
                <li><strong>Correction des valeurs</strong> - type.id ‚Üí type.value</li>
                <li><strong>Ajout de v√©rifications</strong> - Validation de la structure des donn√©es</li>
            </ul>
        </div>
    </div>

    <script>
        let authToken = '';

        function showResult(elementId, message, isError = false) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result-box ${isError ? 'error' : 'success'}`;
        }

        function log(message, type = 'info') {
            const resultBox = document.getElementById('testResult');
            const timestamp = new Date().toLocaleTimeString();
            resultBox.textContent += `[${timestamp}] ${message}\n`;
            resultBox.scrollTop = resultBox.scrollHeight;
        }

        async function makeRequest(url, options = {}) {
            if (!authToken) {
                throw new Error('Token d\'authentification requis');
            }

            const response = await fetch(url, {
                ...options,
                headers: {
                    'Authorization': authToken,
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            return response.json();
        }

        async function testDocumentTypesStructure() {
            try {
                authToken = document.getElementById('authToken').value.trim();
                if (!authToken) {
                    showResult('testResult', '‚ùå Veuillez saisir un token d\'authentification', true);
                    return;
                }

                if (!authToken.startsWith('Bearer ')) {
                    authToken = 'Bearer ' + authToken;
                }

                log('üîÑ Test de la structure des types de documents...');
                
                const data = await makeRequest('http://localhost:8080/api/demandes/document-types');
                
                log(`‚úÖ ${data.length} types de documents r√©cup√©r√©s`);
                log(`üìä Structure des donn√©es:`);
                log(JSON.stringify(data, null, 2));

                // V√©rifier la structure
                const hasValidStructure = data.every(type => 
                    type && 
                    typeof type === 'object' && 
                    type.value && 
                    type.label
                );

                if (hasValidStructure) {
                    log('‚úÖ Structure des donn√©es valide (value et label pr√©sents)');
                    showResult('testResult', `‚úÖ Structure des donn√©es valide!\n\n${JSON.stringify(data, null, 2)}`);
                } else {
                    log('‚ùå Structure des donn√©es invalide');
                    showResult('testResult', `‚ùå Structure des donn√©es invalide!\n\n${JSON.stringify(data, null, 2)}`, true);
                }

            } catch (error) {
                log(`‚ùå Erreur: ${error.message}`, 'error');
                showResult('testResult', `‚ùå Erreur: ${error.message}`, true);
            }
        }

        async function testMappingLogic() {
            try {
                if (!authToken) {
                    showResult('testResult', '‚ùå Veuillez d\'abord vous connecter', true);
                    return;
                }

                log('üß† Test de la logique de mapping...');
                
                const data = await makeRequest('http://localhost:8080/api/demandes/document-types');
                
                // Simuler une demande
                const mockDemande = {
                    id: 1,
                    documentTypeDisplay: "Passeport"
                };

                log(`üìã Demande simul√©e: ${JSON.stringify(mockDemande)}`);
                log(`üîç Types disponibles: ${data.length}`);

                // Tester le mapping
                const matchingType = data.find(
                    (type) =>
                        type.label?.toLowerCase() === mockDemande.documentTypeDisplay?.toLowerCase() ||
                        type.label?.toLowerCase().includes(mockDemande.documentTypeDisplay?.toLowerCase()) ||
                        mockDemande.documentTypeDisplay?.toLowerCase().includes(type.label?.toLowerCase())
                );

                if (matchingType) {
                    log(`‚úÖ Type correspondant trouv√©: ${matchingType.label} (ID: ${matchingType.value})`);
                    showResult('testResult', `‚úÖ Mapping r√©ussi!\n\nType trouv√©: ${matchingType.label}\nID: ${matchingType.value}\n\nDemande: ${mockDemande.documentTypeDisplay}`);
                } else {
                    log(`‚ö†Ô∏è Aucun type correspondant trouv√© pour: ${mockDemande.documentTypeDisplay}`);
                    showResult('testResult', `‚ö†Ô∏è Aucun type correspondant trouv√© pour: ${mockDemande.documentTypeDisplay}\n\nTypes disponibles:\n${data.map(t => `- ${t.label} (${t.value})`).join('\n')}`);
                }

            } catch (error) {
                log(`‚ùå Erreur: ${error.message}`, 'error');
                showResult('testResult', `‚ùå Erreur: ${error.message}`, true);
            }
        }

        async function runCompleteTest() {
            try {
                if (!authToken) {
                    showResult('testResult', '‚ùå Veuillez d\'abord vous connecter', true);
                    return;
                }

                showResult('testResult', 'üß™ D√©marrage du test complet...\n\n');

                // 1. Tester la structure
                log('1Ô∏è‚É£ Test de la structure des donn√©es...');
                await testDocumentTypesStructure();
                
                // 2. Tester le mapping
                log('2Ô∏è‚É£ Test de la logique de mapping...');
                await testMappingLogic();
                
                // 3. V√©rifier la robustesse
                log('3Ô∏è‚É£ Test de robustesse...');
                const data = await makeRequest('http://localhost:8080/api/demandes/document-types');
                
                // V√©rifier que chaque type a les propri√©t√©s requises
                const validTypes = data.filter(type => 
                    type && 
                    typeof type === 'object' && 
                    type.value && 
                    type.label
                );

                if (validTypes.length === data.length) {
                    log('‚úÖ Tous les types sont valides');
                } else {
                    log(`‚ö†Ô∏è ${data.length - validTypes.length} types invalides d√©tect√©s`);
                }

                log('‚úÖ Test complet termin√©!');
                showResult('testResult', `‚úÖ Test complet termin√©!\n\nLa correction de la structure des donn√©es fonctionne correctement.\n\nTypes valides: ${validTypes.length}/${data.length}`);

            } catch (error) {
                log(`‚ùå Erreur lors du test complet: ${error.message}`, 'error');
                showResult('testResult', `‚ùå Erreur lors du test complet: ${error.message}`, true);
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            log('üß™ Page de test charg√©e');
            log('üìã Instructions:');
            log('1. Saisissez votre token d\'authentification');
            log('2. Testez la structure des types de documents');
            log('3. Testez la logique de mapping');
            log('4. Lancez le test complet');
        });
    </script>
</body>
</html>
